module Watir
  module Generator
    class Base

      def generate(spec_url, io = StringIO.new)
        @spec_url, @io = spec_url, io
        @hash = {}

        get_idls

        write_header
        write_class_defs
        # write_container_methods
         write_footer

         io
      end

      private

      def get_idls
        Nokogiri::HTML(File.read(@spec_url)).css('pre.idl').each do |idl|
          first_span = idl.at_css('span')
          next if first_span.nil?

          dfn = idl.at_css('dfn')
          next if !dfn.nil? && dfn.inner_html == "DocumentReadyState"

          constructor = first_span.inner_html == 'HTMLConstructor'
          partial_interface = idl.inner_html.include?('partial interface') && first_span.inner_html[/HTML(.*)Element/]
          no_interface = idl.inner_html.include?('NoInterfaceObject') && dfn.inner_html =~ /ElementContentEditable|GlobalEventHandlers/

          next unless constructor || partial_interface || no_interface

          if constructor
            element = dfn.inner_html[/HTML(.*)Element/, 1]
            element = 'HTMLElement' if element.empty?
          elsif partial_interface
            element = first_span.inner_html[/HTML(.*)Element/, 1]
          else
            element = 'HTMLElement'
          end
          @hash[element] ||= []

          spans = {}
          idl.css('span[data-x]').each do |c|
            spans[c.inner_html] = ''
          end

          idl.text.split("\n").select {|a| a.include? 'attribute '}.map do |a|
            attribute = a[/(\S*) (\S*);/, 2]
            type  = a[/(\S*) (\S*);/, 1]
            @hash[element] << {attribute => type}
          end
        end
      end

      def write_header
        @io.puts "# Autogenerated from #{generator_implementation} specification. Edits may be lost."
        @io.puts "module Watir"
      end

      def write_class_defs
        @hash.each do |k, v|
          @io.puts "  class #{k} < Element"
          v.each do |h|
            type = h.values.first
            snake = snake_case(h.keys.first)

            if type == 'boolean'
              snake = "#{snake}?"
              type = '"Boolean"'
            elsif type == 'long'
              type = 'Integer'
            elsif type == 'double'
              type = 'Float'
            else
              type = 'String'
            end
            @io.puts "    attribute(#{type}, :#{snake}, :#{h.keys.first})\n"
          end
          @io.puts "  end\n"
          @io.puts "  class #{k}Collection < ElementCollection\n"
          @io.puts "  end\n\n"
        end
      end

      def snake_case(str)
        str.gsub(/\B[A-Z][^A-Z]/, '_\&').downcase.gsub(' ', '_')
      end

      def write_container_methods
        @io.puts "\n"
        @io.puts indent("module Container")

        @tag2interfaces.sort.each do |tag, interfaces|
          raise "multiple interfaces for tag #{tag.inspect}" if interfaces.map(&:name).uniq.size != 1

          tag_string       = tag.inspect
          singular         = Util.paramify(visitor.classify_regexp, tag)
          plural           = singular.pluralize
          element_class    = Util.classify(visitor.classify_regexp, interfaces.first.name)
          collection_class = "#{element_class}Collection"

          # visitor.visit_tag(tag, interfaces.first.name) !?
          @io.puts indent(<<-CODE, 2)

# @return [#{element_class}]
def #{singular}(*args)
  #{element_class}.new(self, extract_selector(args).merge(tag_name: #{tag_string}))
end
# @return [#{collection_class}]
def #{plural}(*args)
  #{collection_class}.new(self, extract_selector(args).merge(tag_name: #{tag_string}))
end
Watir.tag_to_class[#{tag.to_sym.inspect}] = #{element_class}

CODE
        end

        @io.puts indent("end # Container")
      end

      def write_footer
        @io.puts "end # Watir"
      end

      def indent(code, indent = 1)
        indent_string = "  " * indent
        code.split("\n").map { |line| line.empty? ? line : indent_string + line }.join("\n")
      end

    end # Base
  end # Generator
end # Watir
