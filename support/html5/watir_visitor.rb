# encoding: utf-8
require "rubygems"
require "webidl"
require "pp"
require File.expand_path("spec_extractor", File.dirname(__FILE__))

require "active_support/inflector"
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'body', 'bodys'
  inflect.irregular 'tbody', 'tbodys'
  inflect.irregular 'canvas', 'canvases'
  inflect.irregular 'ins', 'inses' # made up.
end

class WatirVisitor < WebIDL::RubySexpVisitor

  SPECIALS = {
    'img' => 'image'
  }


  # TODO: clean this up
  def self.generate_from(spec)
    generator = WebIDL::Generator.new(new)
    extractor = SpecExtractor.new(spec)
    tag2interfaces = extractor.process

    result = []
    result << "# Autogenerated from the HTML5 specification. Edits may be lost."
    result << "module Watir"

    # element class definitions
    extractor.sorted_interfaces.each do |interface|
      result << indent(generator.generate(interface)).chomp
    end

    # collection class definitions
    tag2interfaces.each_value.map { |interfaces| classify(interfaces.first.name) }.uniq.each do |name|
      result << "  class #{name}Collection < ElementCollection; end"
    end

    # container methods
    result << "  module Container"
    tag2interfaces.each do |tag, interfaces|
      raise "multiple interfaces match tag #{tag.inspect}" unless interfaces.map { |e| e.name }.uniq.size == 1

      tag_sym          = tag.to_sym.inspect
      singular         = paramify(tag)
      plural           = singular.pluralize
      element_class    = classify(interfaces.first.name)
      collection_class = "#{element_class}Collection"

      result << <<-CODE
    Watir.tag_to_class[#{tag_sym}] = #{element_class}

    #
    # @return [#{element_class}]
    #

    def #{singular}(*args)
      #{element_class}.new(self, {:tag_name => #{tag_sym}}, *args)
    end

    #
    # @return [#{collection_class}]
    #

    def #{plural}(*args)
      #{collection_class}.new(self, {:tag_name => #{tag_sym}}, #{element_class}, *args)
    end
      CODE
    end

    result << "  end # Container"
    result << "end # Watir"

    result.compact.join("\n")
  end

  def initialize
    super

    # When an interface has multiple IDL definitions, the inheritance is sometimes
    # not repeated. So we'll keep track ourselves.

    @inheritance_map = {}
  end

  def visit_interface(interface)
    name   = interface.name
    parent = interface.inherits.first

    $stderr.puts name
    return unless name =~ /^HTML/ && name !~ /(Collection|Document)$/

    if name == "HTMLElement"
      parent = 'Element'
    elsif parent
      @inheritance_map[name] ||= parent.name
      parent = parent.name
    else
      parent = @inheritance_map[name] || return
    end

    element_class interface.name,
                  interface.members.select { |e| e.kind_of?(WebIDL::Ast::Attribute) },
                  parent
  end

  def visit_module(mod)
    # ignored
  end

  def visit_implements_statement(stmt)
    # ignored
  end

  private

  def element_class(name, attributes, parent)
    sexp = [:class, classify(name), [:const, classify(parent)]]

    # if tag_name
    #   sexp << [:scope, [:block] + [identifier_call(tag_name)]]
    #   sexp << [:scope, [:block] + [container_call(tag_name)]]
    #   sexp << [:scope, [:block] + [collection_call(tag_name)]]
    # end

    sexp << [:scope, [:block] + [attributes_call(attributes)]]

    sexp
  end

  def self.classify(name)
    if name =~ /^HTML(.+)Element$/
      $1
    else
      name
    end
  end

  def classify(name)
    self.class.classify(name)
  end

  def paramify(str)
    self.class.paramify(str)
  end

  def self.paramify(str)
    if SPECIALS.has_key?(str)
      SPECIALS[str]
    else
      classify(str).snake_case
    end
  end

  def self.indent(code)
    "  " + code.split("\n").join("\n  ")
  end

  def attributes_call(attributes)
    return if attributes.empty?

    attrs = Hash.new { |hash, key| hash[key] = [] }
    attributes.each do |a|
      attrs[ruby_type_for(a.type)] << a.name.snake_case
    end

    call :attributes, [[:hash] + attrs.map { |type, names| [[:lit, type], literal_array(names)] }.flatten(1)]
  end

  def identifier_call(tag_name)
    call :identifier, [literal_hash(:tag_name => tag_name)]
  end

  def container_call(name)
    call :container_method,  [[:lit, paramify(name).to_sym]]
  end

  def collection_call(name)
    call :collection_method, [[:lit, paramify(name).pluralize.to_sym]]
  end

  def literal_hash(hash)
    [:hash] + hash.map { |k, v| [[:lit, k.to_sym], [:lit, v]] }.flatten(1)
  end

  def literal_array(arr)
    [:array] + arr.map { |e| [:lit, e.to_sym] }
  end

  def call(name, args)
    [:call, nil, name.to_sym, [:arglist] + args]
  end

  def ruby_type_for(type)
    case type.name.to_s
    when 'DOMString', 'any'
      :string
    when 'UnsignedLong', 'Long', 'Integer', 'Short', 'UnsignedShort'
      :int
    when 'Float', 'Double'
      :float
    when 'Function'
      :function
    when 'Boolean'
      :bool
    when 'Document'
      :document
    when 'DOMTokenList', 'DOMSettableTokenList'
      :token_list
    when 'DOMStringMap'
      :string_map
    when 'HTMLPropertiesCollection'
      :properties_collection
    when /HTML(.*)Element/
      :html_element
    when /HTML(.*)Collection/
      :html_collection
    when 'CSSStyleDeclaration'
      :style
    when /.+List$/
      :list
    when 'Date'
      :date
    when 'Element'
      :element
    when 'WindowProxy', 'ValidityState', 'MediaError', 'TimeRanges', 'Location', 'Any', 'TimedTrackArray', 'TimedTrack'
      # probably completely wrong.
      :string
    else
      raise "unknown type: #{type.name}"
    end
  end

end
